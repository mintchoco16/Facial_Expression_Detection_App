# -*- coding: utf-8 -*-
"""expression_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ab8PCl3ypCeZ-8clmeAJB1NsDT_qph6n
"""

# Install necessary packages
#!pip install numpy==1.23.5  # Compatible version based on existing dependencies
#!pip install opencv-python-headless==4.9.0.80  # OpenCV library for image processing
#!pip install tensorflow==2.12.0  # TensorFlow deep learning framework
#!pip install keras==2.12.0  # Keras high-level neural networks API
#!pip install streamlit==1.35.0  # Streamlit for creating web applications

# Additional packages for visualization and data handling
#!pip install pydeck==0.9.1  # Pydeck for 3D visualization
#!pip install gitpython==3.1.43  # GitPython for interacting with Git repositories
#!pip install watchdog==4.0.1  # Watchdog for monitoring file system events

# Restart runtime to apply the changes

#!pip install tensorflow==2.12.0

import numpy as np
#import tensorflow as tf
from tensorflow import keras
import streamlit as st

import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import to_categorical

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Preprocess the data
x_train = np.expand_dims(x_train, axis=-1) / 255.0
x_test = np.expand_dims(x_test, axis=-1) / 255.0
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)

# Define the model architecture
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(10, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(x_train, y_train, epochs=5, validation_data=(x_test, y_test))

# Save the trained model
model.save("mnist_model.h5")

import numpy as np
import cv2
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model("mnist_model.h5")

# Define a function to make predictions on new images
def predict_digit(image):
    # Preprocess the image
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    image = cv2.resize(image, (28, 28))
    image = np.expand_dims(image, axis=-1)
    image = np.expand_dims(image, axis=0)

    # Make predictions
    predictions = model.predict(image)
    digit = np.argmax(predictions)
    return digit

import numpy as np
from PIL import Image
from tensorflow.keras.models import load_model
import streamlit as st

# Load the trained model
model = load_model("mnist_model.h5")

# Define a function to make predictions on new images
def predict_digit(image):
    # Preprocess the image
    image = image.convert("L")  # Convert to grayscale
    image = image.resize((28, 28))  # Resize to 28x28
    image = np.expand_dims(image, axis=0)  # Add batch dimension
    image = np.expand_dims(image, axis=-1)  # Add channel dimension
    image = image / 255.0  # Normalize pixel values

    # Make predictions
    predictions = model.predict(image)
    digit = np.argmax(predictions)
    return digit

def main():
    st.title("MNIST Digit Recognition")

    uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "png"])

    if uploaded_file is not None:
        image = Image.open(uploaded_file)
        st.image(image, caption="Uploaded Image", use_column_width=True)

        if st.button("Predict"):
            digit = predict_digit(image)
            st.success(f"Predicted Digit: {digit}")

if __name__ == "__main__":
    main()


#pip install streamlit
